% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{fdasrsf Documentation}
\date{September 28, 2013}
\release{1.1.0}
\author{J. Derek Tucker}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


A python package for functional data analysis using the square root slope framework which performs pair-wise and
group-wise alignment as well as modeling using functional component analysis.


\chapter{Functional Alignment}
\label{time_warping:module-time_warping}\label{time_warping:functional-alignment}\label{time_warping::doc}\label{time_warping:welcome-to-fdasrsf-s-documentation}\index{time\_warping (module)}
Group-wise function alignment using SRSF framework and Dynamic Programming

moduleauthor:: Derek Tucker \textless{}\href{mailto:dtucker@stat.fsu.edu}{dtucker@stat.fsu.edu}\textgreater{}
\index{align\_fPCA() (in module time\_warping)}

\begin{fulllineitems}
\phantomsection\label{time_warping:time_warping.align_fPCA}\pysiglinewithargsret{\code{time\_warping.}\bfcode{align\_fPCA}}{\emph{f}, \emph{time}, \emph{num\_comp=3}, \emph{showplot=True}, \emph{smoothdata=False}}{}
aligns a collection of functions while extracting principal components. The functions are aligned to the principal
components
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} (\emph{np.ndarray}) -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{time} (\emph{np.ndarray}) -- vector of size N describing the sample points

\item {} 
\textbf{num\_comp} -- number of fPCA components

\item {} 
\textbf{showplot} -- Shows plots of results using matplotlib (default = T)

\item {} 
\textbf{smooth\_data} (\href{http://docs.python.org/library/functions.html\#bool}{\emph{bool}}) -- Smooth the data using a box filter (default = F)

\item {} 
\textbf{sparam} (\emph{double}) -- Number of times to run box filter (default = 25)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return fn}] \leavevmode
aligned functions - numpy ndarray of shape (M,N) of M functions with N samples

\item[{Return qn}] \leavevmode
aligned srvfs - similar structure to fn

\item[{Return q0}] \leavevmode
original srvf - similar structure to fn

\item[{Return mqn}] \leavevmode
srvf mean or median - vector of length N

\item[{Return gam}] \leavevmode
warping functions - similar structure to fn

\item[{Return q\_pca}] \leavevmode
srsf principal directions

\item[{Return f\_pca}] \leavevmode
functional principal directions

\item[{Return latent}] \leavevmode
latent values

\item[{Return coef}] \leavevmode
coefficients

\item[{Return U}] \leavevmode
eigenvectors

\end{description}\end{quote}

\end{fulllineitems}

\index{align\_fPLS() (in module time\_warping)}

\begin{fulllineitems}
\phantomsection\label{time_warping:time_warping.align_fPLS}\pysiglinewithargsret{\code{time\_warping.}\bfcode{align\_fPLS}}{\emph{f}, \emph{g}, \emph{time}, \emph{comps=3}, \emph{showplot=True}, \emph{smoothdata=False}, \emph{max\_itr=100}}{}
This function aligns a collection of functions while performing principal least squares
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} (\emph{np.ndarray}) -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{g} (\emph{np.ndarray}) -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{time} (\emph{np.ndarray}) -- vector of size N describing the sample points

\item {} 
\textbf{comps} -- number of fPLS components

\item {} 
\textbf{showplot} -- Shows plots of results using matplotlib (default = T)

\item {} 
\textbf{smooth\_data} (\href{http://docs.python.org/library/functions.html\#bool}{\emph{bool}}) -- Smooth the data using a box filter (default = F)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return fn}] \leavevmode
aligned functions - numpy ndarray of shape (M,N) of M functions with N samples

\item[{Return gn}] \leavevmode
aligned functions - numpy ndarray of shape (M,N) of M functions with N samples

\item[{Return qfn}] \leavevmode
aligned srvfs - similar structure to fn

\item[{Return qgn}] \leavevmode
aligned srvfs - similar structure to fn

\item[{Return qf0}] \leavevmode
original srvf - similar structure to fn

\item[{Return qg0}] \leavevmode
original srvf - similar structure to fn

\item[{Return gam}] \leavevmode
warping functions - similar structure to fn

\item[{Return wqf}] \leavevmode
srsf principal weight functions

\item[{Return wqg}] \leavevmode
srsf principal weight functions

\item[{Return wf}] \leavevmode
srsf principal weight functions

\item[{Return wg}] \leavevmode
srsf principal weight functions

\item[{Return cost}] \leavevmode
cost function value

\end{description}\end{quote}

\end{fulllineitems}

\index{srsf\_align() (in module time\_warping)}

\begin{fulllineitems}
\phantomsection\label{time_warping:time_warping.srsf_align}\pysiglinewithargsret{\code{time\_warping.}\bfcode{srsf\_align}}{\emph{f}, \emph{time}, \emph{method='mean'}, \emph{showplot=True}, \emph{smoothdata=False}, \emph{lam=0.0}}{}
This function aligns a collection of functions using the elastic square-root slope (srsf) framework.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} (\emph{np.ndarray}) -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{time} (\emph{np.ndarray}) -- vector of size N describing the sample points

\item {} 
\textbf{method} -- (string) warp calculate Karcher Mean or Median (options = ``mean'' or ``median'') (default=''mean'')

\item {} 
\textbf{showplot} -- Shows plots of results using matplotlib (default = T)

\item {} 
\textbf{smoothdata} (\href{http://docs.python.org/library/functions.html\#bool}{\emph{bool}}) -- Smooth the data using a box filter (default = F)

\item {} 
\textbf{sparam} (\emph{double}) -- Number of times to run box filter (default = 25)

\item {} 
\textbf{lam} (\emph{double}) -- controls the elasticity (default = 0)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return fn}] \leavevmode
aligned functions - numpy ndarray of shape (M,N) of M functions with N samples

\item[{Return qn}] \leavevmode
aligned srvfs - similar structure to fn

\item[{Return q0}] \leavevmode
original srvf - similar structure to fn

\item[{Return fmean}] \leavevmode
function mean or median - vector of length N

\item[{Return mqn}] \leavevmode
srvf mean or median - vector of length N

\item[{Return gam}] \leavevmode
warping functions - similar structure to fn

\item[{Return orig\_var}] \leavevmode
Original Variance of Functions

\item[{Return amp\_var}] \leavevmode
Amplitude Variance

\item[{Return phase\_var}] \leavevmode
Phase Variance

\end{description}\end{quote}

Examples
\textgreater{}\textgreater{}\textgreater{} import tables
\textgreater{}\textgreater{}\textgreater{} fun=tables.open\_file(''../Data/simu\_data.h5'')
\textgreater{}\textgreater{}\textgreater{} f = fun.root.f{[}:{]}
\textgreater{}\textgreater{}\textgreater{} f = f.transpose()
\textgreater{}\textgreater{}\textgreater{} time = fun.root.time{[}:{]}
\textgreater{}\textgreater{}\textgreater{} out = srsf\_align(f,time)

\end{fulllineitems}



\chapter{Functional Principal Component Analysis}
\label{fPCA:module-fPCA}\label{fPCA::doc}\label{fPCA:functional-principal-component-analysis}\index{fPCA (module)}
Vertical and Horizontal Functional Principal Component Analysis using SRSF

moduleauthor:: Derek Tucker \textless{}\href{mailto:dtucker@stat.fsu.edu}{dtucker@stat.fsu.edu}\textgreater{}
\index{horizfPCA() (in module fPCA)}

\begin{fulllineitems}
\phantomsection\label{fPCA:fPCA.horizfPCA}\pysiglinewithargsret{\code{fPCA.}\bfcode{horizfPCA}}{\emph{gam}, \emph{time}, \emph{no}, \emph{showplot=True}}{}
This function calculates horizontal functional principal component analysis on aligned data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{gam} -- numpy ndarray of shape (M,N) of M warping functions

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{no} (\href{http://docs.python.org/library/functions.html\#int}{\emph{int}}) -- number of components to extract (default = 1)

\item {} 
\textbf{showplot} (\href{http://docs.python.org/library/functions.html\#bool}{\emph{bool}}) -- Shows plots of results using matplotlib (default = T)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy ndarray

\item[{Return q\_pca}] \leavevmode
srsf principal directions

\item[{Return f\_pca}] \leavevmode
functional principal directions

\item[{Return latent}] \leavevmode
latent values

\item[{Return coef}] \leavevmode
coefficients

\item[{Return U}] \leavevmode
eigenvectors

\end{description}\end{quote}

\end{fulllineitems}

\index{vertfPCA() (in module fPCA)}

\begin{fulllineitems}
\phantomsection\label{fPCA:fPCA.vertfPCA}\pysiglinewithargsret{\code{fPCA.}\bfcode{vertfPCA}}{\emph{fn}, \emph{time}, \emph{qn}, \emph{no=1}, \emph{showplot=True}}{}
This function calculates vertical functional principal component analysis on aligned data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{fn} -- numpy ndarray of shape (M,N) of M aligned functions with N samples

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{qn} -- numpy ndarray of shape (M,N) of M aligned SRSF with N samples

\item {} 
\textbf{no} (\href{http://docs.python.org/library/functions.html\#int}{\emph{int}}) -- number of components to extract (default = 1)

\item {} 
\textbf{showplot} (\href{http://docs.python.org/library/functions.html\#bool}{\emph{bool}}) -- Shows plots of results using matplotlib (default = T)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy ndarray

\item[{Return q\_pca}] \leavevmode
srsf principal directions

\item[{Return f\_pca}] \leavevmode
functional principal directions

\item[{Return latent}] \leavevmode
latent values

\item[{Return coef}] \leavevmode
coefficients

\item[{Return U}] \leavevmode
eigenvectors

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Functional Principal Least Squares}
\label{fPLS:functional-principal-least-squares}\label{fPLS::doc}\label{fPLS:module-fPLS}\index{fPLS (module)}
Partial Least Squares using SVD

moduleauthor:: Derek Tucker \textless{}\href{mailto:dtucker@stat.fsu.edu}{dtucker@stat.fsu.edu}\textgreater{}
\index{pls\_svd() (in module fPLS)}

\begin{fulllineitems}
\phantomsection\label{fPLS:fPLS.pls_svd}\pysiglinewithargsret{\code{fPLS.}\bfcode{pls\_svd}}{\emph{time}, \emph{qf}, \emph{qg}, \emph{no}, \emph{alpha=0.0}}{}
This function computes the partial least squares using SVD
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{time} -- vector describing time samples

\item {} 
\textbf{qf} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{qg} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{no} -- number of components

\item {} 
\textbf{alpha} -- amount of smoothing (Default = 0.0 i.e., none)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return wqf}] \leavevmode
f weight function

\item[{Return wqg}] \leavevmode
g weight function

\item[{Return alpha}] \leavevmode
smoothing value

\item[{Return values}] \leavevmode
singular values

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Utility Functions}
\label{utility_functions:module-utility_functions}\label{utility_functions::doc}\label{utility_functions:utility-functions}\index{utility\_functions (module)}
Utility functions for SRSF Manipulations

moduleauthor:: Derek Tucker \textless{}\href{mailto:dtucker@stat.fsu.edu}{dtucker@stat.fsu.edu}\textgreater{}
\index{SqrtMean() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.SqrtMean}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{SqrtMean}}{\emph{gam}}{}
calculates the srsf of warping functions with corresponding shooting vectors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{gam} -- numpy ndarray of shape (M,N) of M warping functions with N samples

\item[{Return type}] \leavevmode
2 numpy ndarray and vector

\item[{Return mu}] \leavevmode
Karcher mean psi function

\item[{Return gam\_mu}] \leavevmode
vector of dim N which is the Karcher mean warping function

\item[{Return psi}] \leavevmode
numpy ndarray of shape (M,N) of M SRSF of the warping functions

\item[{Return vec}] \leavevmode
numpy ndarray of shape (M,N) of M shooting vectors

\end{description}\end{quote}

\end{fulllineitems}

\index{SqrtMeanInverse() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.SqrtMeanInverse}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{SqrtMeanInverse}}{\emph{gam}}{}
finds the inverse of the mean of the set of the diffeomorphisms gamma
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{gam} -- numpy ndarray of shape (M,N) of M warping functions with N samples

\item[{Return type}] \leavevmode
vector

\item[{Return gamI}] \leavevmode
inverse of gam

\end{description}\end{quote}

\end{fulllineitems}

\index{cumtrapzmid() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.cumtrapzmid}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{cumtrapzmid}}{\emph{x}, \emph{y}, \emph{c}}{}
cumulative trapezoidal numerical integration taken from midpoint
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{x} -- vector of size N describing the time samples

\item {} 
\textbf{y} -- vector of size N describing the function

\item {} 
\textbf{c} -- midpoint

\end{itemize}

\item[{Return type}] \leavevmode
vector

\item[{Return fa}] \leavevmode
cumulative integration

\end{description}\end{quote}

\end{fulllineitems}

\index{diffop() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.diffop}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{diffop}}{\emph{n}, \emph{binsize=1}}{}
Creates a second order differential operator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{n} -- dimension

\item {} 
\textbf{binsize} -- dx (default = 1)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return m}] \leavevmode
matrix describing differential operator

\end{description}\end{quote}

\end{fulllineitems}

\index{elastic\_distance() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.elastic_distance}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{elastic\_distance}}{\emph{f1}, \emph{f2}, \emph{time}, \emph{lam=0.0}}{}
''
calculates the distances between function, where f1 is aligned to f2. In other words
calculates the elastic distances
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f1} -- vector of size N

\item {} 
\textbf{f2} -- vector of size N

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{lam} -- controls the elasticity (default = 0.0)

\end{itemize}

\item[{Return type}] \leavevmode
scalar

\item[{Return Dy}] \leavevmode
amplitude distance

\item[{Return Dx}] \leavevmode
phase distance

\end{description}\end{quote}

\end{fulllineitems}

\index{f\_to\_srsf() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.f_to_srsf}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{f\_to\_srsf}}{\emph{f}, \emph{time}}{}
converts f to a square-root slope function (SRSF)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} -- vector of size N samples

\item {} 
\textbf{time} -- vector of size N describing the sample points

\end{itemize}

\item[{Return type}] \leavevmode
vector

\item[{Return q}] \leavevmode
srsf of f

\end{description}\end{quote}

\end{fulllineitems}

\index{geigen() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.geigen}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{geigen}}{\emph{Amat}, \emph{Bmat}, \emph{Cmat}}{}
generalized eigenvalue problem of the form

max tr L'AM / sqrt(tr L'BL tr M'CM) w.r.t. L and M

:param Amat numpy ndarray of shape (M,N)
:param Bmat numpy ndarray of shape (M,N)
:param Bmat numpy ndarray of shape (M,N)
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return values}] \leavevmode
eigenvalues

\item[{Return Lmat}] \leavevmode
left eigenvectors

\item[{Return Mmat}] \leavevmode
right eigenvectors

\end{description}\end{quote}

\end{fulllineitems}

\index{gradient\_spline() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.gradient_spline}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{gradient\_spline}}{\emph{time}, \emph{f}, \emph{smooth=False}}{}
This function takes the gradient of f using b-spline smoothing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{f} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{smooth} -- smooth data (default = F)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy ndarray

\item[{Return f0}] \leavevmode
smoothed functions functions

\item[{Return g}] \leavevmode
first derivative of each function

\item[{Return g2}] \leavevmode
second derivative of each function

\end{description}\end{quote}

\end{fulllineitems}

\index{innerprod\_q() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.innerprod_q}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{innerprod\_q}}{\emph{time}, \emph{q1}, \emph{q2}}{}
calculates the innerproduct between two srsfs

:param time vector descrbing time samples
:param q1 vector of srsf 1
:param q2 vector of srsf 2
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
scalar

\item[{Return val}] \leavevmode
inner product value

\end{description}\end{quote}

\end{fulllineitems}

\index{invertGamma() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.invertGamma}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{invertGamma}}{\emph{gam}}{}
finds the inverse of the diffeomorphism gamma
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{gam} -- vector describing the warping function

\item[{Return type}] \leavevmode
vector

\item[{Return gamI}] \leavevmode
inverse of gam

\end{description}\end{quote}

\end{fulllineitems}

\index{optimum\_reparam() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.optimum_reparam}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{optimum\_reparam}}{\emph{q1}, \emph{time}, \emph{q2}, \emph{lam=0.0}}{}
calculates the warping to align srsf q2 to q1
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{q1} -- vector of size N or array of NxM samples of first SRSF

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{q2} -- vector of size N or array of NxM samples samples of second SRSF

\item {} 
\textbf{lam} -- controls the amount of elasticity (default = 0.0)

\end{itemize}

\item[{Return type}] \leavevmode
vector

\item[{Return gam}] \leavevmode
describing the warping function used to align q2 with q1

\end{description}\end{quote}

\end{fulllineitems}

\index{outlier\_detection() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.outlier_detection}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{outlier\_detection}}{\emph{q}, \emph{time}, \emph{mq}, \emph{k=1.5}}{}
calculates outlier's using geodesic distances of the SRSFs from the median
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{q} -- numpy ndarray of N x M of M SRS functions with N samples

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{mq} -- median calculated using {\hyperref[time_warping:time_warping.srsf_align]{\code{time\_warping.srsf\_align()}}}

\item {} 
\textbf{k} -- cutoff threshold (default = 1.5)

\end{itemize}

\item[{Returns}] \leavevmode
q\_outlier: outlier functions

\end{description}\end{quote}

\end{fulllineitems}

\index{randomGamma() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.randomGamma}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{randomGamma}}{\emph{gam}, \emph{num}}{}
generates random warping functions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{gam} -- numpy ndarray of N x M of M of warping functions

\item {} 
\textbf{num} -- number of random functions

\end{itemize}

\item[{Returns}] \leavevmode
rgam: random warping functions

\end{description}\end{quote}

\end{fulllineitems}

\index{rgam() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.rgam}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{rgam}}{\emph{N}, \emph{sigma}, \emph{num}}{}
Generates random warping functions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{N} -- length of warping function

\item {} 
\textbf{sigma} -- variance of warping functions

\item {} 
\textbf{num} -- number of warping functions

\end{itemize}

\item[{Returns}] \leavevmode
gam: numpy ndarray of warping functions

\end{description}\end{quote}

\end{fulllineitems}

\index{smooth\_data() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.smooth_data}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{smooth\_data}}{\emph{f}, \emph{sparam}}{}
This function smooths a collection of functions using a box filter
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{sparam} -- Number of times to run box filter (default = 25)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return f}] \leavevmode
smoothed functions functions

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_progress() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.update_progress}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{update\_progress}}{\emph{progress}}{}
This function creates a progress bar
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{progress} -- fraction of progress

\end{description}\end{quote}

\end{fulllineitems}

\index{warp\_q\_gamma() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.warp_q_gamma}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{warp\_q\_gamma}}{\emph{time}, \emph{q}, \emph{gam}}{}
warps a srsf q by gam

:param time vector describing time samples
:param q vector describing srsf
:param gam vector describing warping function
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return q\_temp}] \leavevmode
warped srsf

\end{description}\end{quote}

\end{fulllineitems}


References:
\begin{quote}

Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S., May 2011. Registration of functional data using
fisher-rao metric, arXiv:1103.3817v2 {[}math.ST{]}.

Tucker, J. D., Wu, W., Srivastava, A., Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
\end{quote}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{f}
\item {\texttt{fPCA}}, \pageref{fPCA:module-fPCA}
\item {\texttt{fPLS}}, \pageref{fPLS:module-fPLS}
\indexspace
\bigletter{t}
\item {\texttt{time\_warping}}, \pageref{time_warping:module-time_warping}
\indexspace
\bigletter{u}
\item {\texttt{utility\_functions}}, \pageref{utility_functions:module-utility_functions}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
