% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{fdasrsf Documentation}
\date{February 06, 2014}
\release{1.2.0}
\author{J. Derek Tucker}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


A python package for functional data analysis using the square root
slope framework and curves using the square root velocity framework
which performs pair-wise and group-wise alignment as well as modeling
using functional component analysis and regression.


\chapter{Functional Alignment}
\label{time_warping:functional-alignment}\label{time_warping:module-time_warping}\label{time_warping:welcome-to-fdasrsf-s-documentation}\label{time_warping::doc}\index{time\_warping (module)}
Group-wise function alignment using SRSF framework and Dynamic Programming

moduleauthor:: Derek Tucker \textless{}\href{mailto:dtucker@stat.fsu.edu}{dtucker@stat.fsu.edu}\textgreater{}
\index{align\_fPCA() (in module time\_warping)}

\begin{fulllineitems}
\phantomsection\label{time_warping:time_warping.align_fPCA}\pysiglinewithargsret{\code{time\_warping.}\bfcode{align\_fPCA}}{\emph{f}, \emph{time}, \emph{num\_comp=3}, \emph{showplot=True}, \emph{smoothdata=False}}{}
aligns a collection of functions while extracting principal components. The functions are aligned to the principal
components
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} (\emph{np.ndarray}) -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{time} (\emph{np.ndarray}) -- vector of size N describing the sample points

\item {} 
\textbf{num\_comp} -- number of fPCA components

\item {} 
\textbf{showplot} -- Shows plots of results using matplotlib (default = T)

\item {} 
\textbf{smooth\_data} (\href{http://docs.python.org/library/functions.html\#bool}{\emph{bool}}) -- Smooth the data using a box filter (default = F)

\item {} 
\textbf{sparam} (\emph{double}) -- Number of times to run box filter (default = 25)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return fn}] \leavevmode
aligned functions - numpy ndarray of shape (M,N) of M functions with N samples

\item[{Return qn}] \leavevmode
aligned srvfs - similar structure to fn

\item[{Return q0}] \leavevmode
original srvf - similar structure to fn

\item[{Return mqn}] \leavevmode
srvf mean or median - vector of length N

\item[{Return gam}] \leavevmode
warping functions - similar structure to fn

\item[{Return q\_pca}] \leavevmode
srsf principal directions

\item[{Return f\_pca}] \leavevmode
functional principal directions

\item[{Return latent}] \leavevmode
latent values

\item[{Return coef}] \leavevmode
coefficients

\item[{Return U}] \leavevmode
eigenvectors

\end{description}\end{quote}

\end{fulllineitems}

\index{align\_fPLS() (in module time\_warping)}

\begin{fulllineitems}
\phantomsection\label{time_warping:time_warping.align_fPLS}\pysiglinewithargsret{\code{time\_warping.}\bfcode{align\_fPLS}}{\emph{f}, \emph{g}, \emph{time}, \emph{comps=3}, \emph{showplot=True}, \emph{smoothdata=False}, \emph{delta=0.01}, \emph{max\_itr=100}}{}
This function aligns a collection of functions while performing
principal least squares
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} (\emph{np.ndarray}) -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{g} (\emph{np.ndarray}) -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{time} (\emph{np.ndarray}) -- vector of size N describing the sample points

\item {} 
\textbf{comps} -- number of fPLS components

\item {} 
\textbf{showplot} -- Shows plots of results using matplotlib (default = T)

\item {} 
\textbf{smooth\_data} (\href{http://docs.python.org/library/functions.html\#bool}{\emph{bool}}) -- Smooth the data using a box filter (default = F)

\item {} 
\textbf{delta} -- gradient step size

\item {} 
\textbf{max\_itr} -- maximum number of iterations

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return fn}] \leavevmode
aligned functions - numpy ndarray of shape (M,N) of M

\end{description}\end{quote}

functions with N samples
:return gn: aligned functions - numpy ndarray of shape (M,N) of M
functions with N samples
:return qfn: aligned srvfs - similar structure to fn
:return qgn: aligned srvfs - similar structure to fn
:return qf0: original srvf - similar structure to fn
:return qg0: original srvf - similar structure to fn
:return gam: warping functions - similar structure to fn
:return wqf: srsf principal weight functions
:return wqg: srsf principal weight functions
:return wf: srsf principal weight functions
:return wg: srsf principal weight functions
:return cost: cost function value

\end{fulllineitems}

\index{srsf\_align() (in module time\_warping)}

\begin{fulllineitems}
\phantomsection\label{time_warping:time_warping.srsf_align}\pysiglinewithargsret{\code{time\_warping.}\bfcode{srsf\_align}}{\emph{f}, \emph{time}, \emph{method='mean'}, \emph{showplot=True}, \emph{smoothdata=False}, \emph{lam=0.0}}{}
This function aligns a collection of functions using the elastic
square-root slope (srsf) framework.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{method} -- (string) warp calculate Karcher Mean or Median

\end{itemize}

\end{description}\end{quote}

(options = ``mean'' or ``median'') (default=''mean'')
:param showplot: Shows plots of results using matplotlib (default = T)
:param smoothdata: Smooth the data using a box filter (default = F)
:param lam: controls the elasticity (default = 0)
:type lam: double
:type smoothdata: bool
:type f: np.ndarray
:type time: np.ndarray
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return fn}] \leavevmode
aligned functions - numpy ndarray of shape (M,N) of M

\end{description}\end{quote}

functions with N samples
:return qn: aligned srvfs - similar structure to fn
:return q0: original srvf - similar structure to fn
:return fmean: function mean or median - vector of length N
:return mqn: srvf mean or median - vector of length N
:return gam: warping functions - similar structure to fn
:return orig\_var: Original Variance of Functions
:return amp\_var: Amplitude Variance
:return phase\_var: Phase Variance

Examples
\textgreater{}\textgreater{}\textgreater{} import tables
\textgreater{}\textgreater{}\textgreater{} fun=tables.open\_file(''../Data/simu\_data.h5'')
\textgreater{}\textgreater{}\textgreater{} f = fun.root.f{[}:{]}
\textgreater{}\textgreater{}\textgreater{} f = f.transpose()
\textgreater{}\textgreater{}\textgreater{} time = fun.root.time{[}:{]}
\textgreater{}\textgreater{}\textgreater{} out = srsf\_align(f,time)

\end{fulllineitems}

\index{srsf\_align\_pair() (in module time\_warping)}

\begin{fulllineitems}
\phantomsection\label{time_warping:time_warping.srsf_align_pair}\pysiglinewithargsret{\code{time\_warping.}\bfcode{srsf\_align\_pair}}{\emph{f}, \emph{g}, \emph{time}, \emph{method='mean'}, \emph{showplot=True}, \emph{smoothdata=False}, \emph{lam=0.0}}{}
This function aligns a collection of functions using the elastic square-root slope (srsf) framework.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} (\emph{np.ndarray}) -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{g} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{time} (\emph{np.ndarray}) -- vector of size N describing the sample points

\item {} 
\textbf{method} -- (string) warp calculate Karcher Mean or Median (options = ``mean'' or ``median'') (default=''mean'')

\item {} 
\textbf{showplot} -- Shows plots of results using matplotlib (default = T)

\item {} 
\textbf{smoothdata} (\href{http://docs.python.org/library/functions.html\#bool}{\emph{bool}}) -- Smooth the data using a box filter (default = F)

\item {} 
\textbf{lam} (\emph{double}) -- controls the elasticity (default = 0)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return fn}] \leavevmode
aligned functions - numpy ndarray of shape (M,N) of M functions with N samples

\item[{Return gn}] \leavevmode
aligned functions - numpy ndarray of shape (M,N) of M functions with N samples

\item[{Return qfn}] \leavevmode
aligned srvfs - similar structure to fn

\item[{Return qgn}] \leavevmode
aligned srvfs - similar structure to fn

\item[{Return qf0}] \leavevmode
original srvf - similar structure to fn

\item[{Return qg0}] \leavevmode
original srvf - similar structure to fn

\item[{Return fmean}] \leavevmode
f function mean or median - vector of length N

\item[{Return gmean}] \leavevmode
g function mean or median - vector of length N

\item[{Return mqfn}] \leavevmode
srvf mean or median - vector of length N

\item[{Return mqgn}] \leavevmode
srvf mean or median - vector of length N

\item[{Return gam}] \leavevmode
warping functions - similar structure to fn

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Functional Principal Component Analysis}
\label{fPCA:module-fPCA}\label{fPCA:functional-principal-component-analysis}\label{fPCA::doc}\index{fPCA (module)}
Vertical and Horizontal Functional Principal Component Analysis using SRSF

moduleauthor:: Derek Tucker \textless{}\href{mailto:dtucker@stat.fsu.edu}{dtucker@stat.fsu.edu}\textgreater{}
\index{horizfPCA() (in module fPCA)}

\begin{fulllineitems}
\phantomsection\label{fPCA:fPCA.horizfPCA}\pysiglinewithargsret{\code{fPCA.}\bfcode{horizfPCA}}{\emph{gam}, \emph{time}, \emph{no}, \emph{showplot=True}}{}
This function calculates horizontal functional principal component analysis on aligned data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{gam} -- numpy ndarray of shape (M,N) of M warping functions

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{no} (\href{http://docs.python.org/library/functions.html\#int}{\emph{int}}) -- number of components to extract (default = 1)

\item {} 
\textbf{showplot} (\href{http://docs.python.org/library/functions.html\#bool}{\emph{bool}}) -- Shows plots of results using matplotlib (default = T)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy ndarray

\item[{Return q\_pca}] \leavevmode
srsf principal directions

\item[{Return f\_pca}] \leavevmode
functional principal directions

\item[{Return latent}] \leavevmode
latent values

\item[{Return coef}] \leavevmode
coefficients

\item[{Return U}] \leavevmode
eigenvectors

\end{description}\end{quote}

\end{fulllineitems}

\index{vertfPCA() (in module fPCA)}

\begin{fulllineitems}
\phantomsection\label{fPCA:fPCA.vertfPCA}\pysiglinewithargsret{\code{fPCA.}\bfcode{vertfPCA}}{\emph{fn}, \emph{time}, \emph{qn}, \emph{no=1}, \emph{showplot=True}}{}
This function calculates vertical functional principal component analysis on aligned data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{fn} -- numpy ndarray of shape (M,N) of M aligned functions with N samples

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{qn} -- numpy ndarray of shape (M,N) of M aligned SRSF with N samples

\item {} 
\textbf{no} (\href{http://docs.python.org/library/functions.html\#int}{\emph{int}}) -- number of components to extract (default = 1)

\item {} 
\textbf{showplot} (\href{http://docs.python.org/library/functions.html\#bool}{\emph{bool}}) -- Shows plots of results using matplotlib (default = T)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy ndarray

\item[{Return q\_pca}] \leavevmode
srsf principal directions

\item[{Return f\_pca}] \leavevmode
functional principal directions

\item[{Return latent}] \leavevmode
latent values

\item[{Return coef}] \leavevmode
coefficients

\item[{Return U}] \leavevmode
eigenvectors

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Gaussian Generative Models}
\label{gauss_model:gaussian-generative-models}\label{gauss_model:module-gauss_model}\label{gauss_model::doc}\index{gauss\_model (module)}
Gaussian Model of functional data

moduleauthor:: Derek Tucker \textless{}\href{mailto:dtucker@stat.fsu.edu}{dtucker@stat.fsu.edu}\textgreater{}
\index{gauss\_model() (in module gauss\_model)}

\begin{fulllineitems}
\phantomsection\label{gauss_model:gauss_model.gauss_model}\pysiglinewithargsret{\code{gauss\_model.}\bfcode{gauss\_model}}{\emph{fn}, \emph{time}, \emph{qn}, \emph{gam}, \emph{n=1}, \emph{sort\_samples=False}}{}
This function models the functional data using a Gaussian model
extracted from the principal components of the srvfs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{fn} -- numpy ndarray of shape (M,N) of M aligned functions with

\end{description}\end{quote}

N samples
:param time: vector of size N describing the sample points
:param qn: numpy ndarray of shape (M,N) of M aligned srvfs with N samples
:param gam: warping functions
:param n: number of random samples
:param sort\_samples: sort samples (default = T)
:type n: integer
:type sort\_samples: bool
:type fn: np.ndarray
:type qn: np.ndarray
:type gam: np.ndarray
:type time: np.ndarray
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return fs}] \leavevmode
random aligned samples

\item[{Return gams}] \leavevmode
random warping functions

\item[{Return ft}] \leavevmode
random samples

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Functional Principal Least Squares}
\label{fPLS:module-fPLS}\label{fPLS:functional-principal-least-squares}\label{fPLS::doc}\index{fPLS (module)}
Partial Least Squares using SVD

moduleauthor:: Derek Tucker \textless{}\href{mailto:dtucker@stat.fsu.edu}{dtucker@stat.fsu.edu}\textgreater{}
\index{pls\_svd() (in module fPLS)}

\begin{fulllineitems}
\phantomsection\label{fPLS:fPLS.pls_svd}\pysiglinewithargsret{\code{fPLS.}\bfcode{pls\_svd}}{\emph{time}, \emph{qf}, \emph{qg}, \emph{no}, \emph{alpha=0.0}}{}
This function computes the partial least squares using SVD
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{time} -- vector describing time samples

\item {} 
\textbf{qf} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{qg} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{no} -- number of components

\item {} 
\textbf{alpha} -- amount of smoothing (Default = 0.0 i.e., none)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return wqf}] \leavevmode
f weight function

\item[{Return wqg}] \leavevmode
g weight function

\item[{Return alpha}] \leavevmode
smoothing value

\item[{Return values}] \leavevmode
singular values

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Elastic Regression}
\label{regression:elastic-regression}\label{regression:module-regression}\label{regression::doc}\index{regression (module)}
Warping Invariant Regression using SRSF

moduleauthor:: Derek Tucker \textless{}\href{mailto:dtucker@stat.fsu.edu}{dtucker@stat.fsu.edu}\textgreater{}
\index{elastic\_logistic() (in module regression)}

\begin{fulllineitems}
\phantomsection\label{regression:regression.elastic_logistic}\pysiglinewithargsret{\code{regression.}\bfcode{elastic\_logistic}}{\emph{f}, \emph{y}, \emph{time}, \emph{B=None}, \emph{df=20}, \emph{max\_itr=20}, \emph{cores=-1}, \emph{smooth=False}}{}
This function identifies a logistic regression model with
phase-variablity using elastic methods
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} (\emph{np.ndarray}) -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{y} -- numpy array of labels (1/-1)

\item {} 
\textbf{time} (\emph{np.ndarray}) -- vector of size N describing the sample points

\item {} 
\textbf{B} -- optional matrix describing Basis elements

\item {} 
\textbf{df} -- number of degrees of freedom B-spline (default 20)

\item {} 
\textbf{max\_itr} -- maximum number of iterations (default 20)

\item {} 
\textbf{cores} -- number of cores for parallel processing (default all)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return alpha}] \leavevmode
alpha parameter of model

\item[{Return beta}] \leavevmode
beta(t) of model

\item[{Return fn}] \leavevmode
aligned functions - numpy ndarray of shape (M,N) of M

\end{description}\end{quote}

functions with N samples
:return qn: aligned srvfs - similar structure to fn
:return gamma: calculated warping functions
:return q: original training SRSFs
:return B: basis matrix
:return b: basis coefficients
:return Loss: logistic loss

\end{fulllineitems}

\index{elastic\_mlogistic() (in module regression)}

\begin{fulllineitems}
\phantomsection\label{regression:regression.elastic_mlogistic}\pysiglinewithargsret{\code{regression.}\bfcode{elastic\_mlogistic}}{\emph{f}, \emph{y}, \emph{time}, \emph{B=None}, \emph{df=20}, \emph{max\_itr=20}, \emph{cores=-1}, \emph{delta=0.01}, \emph{parallel=True}, \emph{smooth=False}}{}
This function identifies a multinomial logistic regression model with
phase-variablity using elastic methods
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} (\emph{np.ndarray}) -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{y} -- numpy array of labels \{1,2,...,m\} for m classes

\item {} 
\textbf{time} (\emph{np.ndarray}) -- vector of size N describing the sample points

\item {} 
\textbf{B} -- optional matrix describing Basis elements

\item {} 
\textbf{df} -- number of degrees of freedom B-spline (default 20)

\item {} 
\textbf{max\_itr} -- maximum number of iterations (default 20)

\item {} 
\textbf{cores} -- number of cores for parallel processing (default all)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return alpha}] \leavevmode
alpha parameter of model

\item[{Return beta}] \leavevmode
beta(t) of model

\item[{Return fn}] \leavevmode
aligned functions - numpy ndarray of shape (M,N) of M

\end{description}\end{quote}

functions with N samples
:return qn: aligned srvfs - similar structure to fn
:return gamma: calculated warping functions
:return q: original training SRSFs
:return B: basis matrix
:return b: basis coefficients
:return Loss: logistic loss

\end{fulllineitems}

\index{elastic\_prediction() (in module regression)}

\begin{fulllineitems}
\phantomsection\label{regression:regression.elastic_prediction}\pysiglinewithargsret{\code{regression.}\bfcode{elastic\_prediction}}{\emph{f}, \emph{time}, \emph{model}, \emph{y=None}, \emph{smooth=False}}{}
This function identifies a regression model with phase-variablity
using elastic methods
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{model} -- indentified model from elastic\_regression

\item {} 
\textbf{y} -- truth, optional used to calculate SSE

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return alpha}] \leavevmode
alpha parameter of model

\item[{Return beta}] \leavevmode
beta(t) of model

\item[{Return fn}] \leavevmode
aligned functions - numpy ndarray of shape (M,N) of M

\end{description}\end{quote}

functions with N samples
:return qn: aligned srvfs - similar structure to fn
:return gamma: calculated warping functions
:return q: original training SRSFs
:return B: basis matrix
:return b: basis coefficients
:return SSE: sum of squared error

\end{fulllineitems}

\index{elastic\_regression() (in module regression)}

\begin{fulllineitems}
\phantomsection\label{regression:regression.elastic_regression}\pysiglinewithargsret{\code{regression.}\bfcode{elastic\_regression}}{\emph{f}, \emph{y}, \emph{time}, \emph{B=None}, \emph{lam=0}, \emph{df=20}, \emph{max\_itr=20}, \emph{cores=-1}, \emph{smooth=False}}{}
This function identifies a regression model with phase-variablity
using elastic methods
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} (\emph{np.ndarray}) -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{y} -- numpy array of N responses

\item {} 
\textbf{time} (\emph{np.ndarray}) -- vector of size N describing the sample points

\item {} 
\textbf{B} -- optional matrix describing Basis elements

\item {} 
\textbf{lam} -- regularization parameter (default 0)

\item {} 
\textbf{df} -- number of degrees of freedom B-spline (default 20)

\item {} 
\textbf{max\_itr} -- maximum number of iterations (default 20)

\item {} 
\textbf{cores} -- number of cores for parallel processing (default all)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return alpha}] \leavevmode
alpha parameter of model

\item[{Return beta}] \leavevmode
beta(t) of model

\item[{Return fn}] \leavevmode
aligned functions - numpy ndarray of shape (M,N) of M

\end{description}\end{quote}

functions with N samples
:return qn: aligned srvfs - similar structure to fn
:return gamma: calculated warping functions
:return q: original training SRSFs
:return B: basis matrix
:return b: basis coefficients
:return SSE: sum of squared error

\end{fulllineitems}

\index{logistic\_warp() (in module regression)}

\begin{fulllineitems}
\phantomsection\label{regression:regression.logistic_warp}\pysiglinewithargsret{\code{regression.}\bfcode{logistic\_warp}}{\emph{beta}, \emph{time}, \emph{q}, \emph{y}}{}
calculates optimal warping for function logistic regression
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{beta} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{q} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{y} -- numpy ndarray of shape (1,N) of M functions with N samples

\end{itemize}

\end{description}\end{quote}

responses
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy array

\item[{Return gamma}] \leavevmode
warping function

\end{description}\end{quote}

\end{fulllineitems}

\index{logit\_gradient() (in module regression)}

\begin{fulllineitems}
\phantomsection\label{regression:regression.logit_gradient}\pysiglinewithargsret{\code{regression.}\bfcode{logit\_gradient}}{\emph{b}, \emph{X}, \emph{y}}{}
calculates gradient of the logistic loss
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{b} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{X} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{y} -- numpy ndarray of shape (1,N) of M functions with N samples

\end{itemize}

\end{description}\end{quote}

responses
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy array

\item[{Return grad}] \leavevmode
gradient of logisitc loss

\end{description}\end{quote}

\end{fulllineitems}

\index{logit\_hessian() (in module regression)}

\begin{fulllineitems}
\phantomsection\label{regression:regression.logit_hessian}\pysiglinewithargsret{\code{regression.}\bfcode{logit\_hessian}}{\emph{s}, \emph{b}, \emph{X}, \emph{y}}{}
calculates hessian of the logistic loss
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{s} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{b} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{X} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{y} -- numpy ndarray of shape (1,N) of M functions with N samples

\end{itemize}

\end{description}\end{quote}

responses
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy array

\item[{Return out}] \leavevmode
hessian of logistic loss

\end{description}\end{quote}

\end{fulllineitems}

\index{logit\_loss() (in module regression)}

\begin{fulllineitems}
\phantomsection\label{regression:regression.logit_loss}\pysiglinewithargsret{\code{regression.}\bfcode{logit\_loss}}{\emph{b}, \emph{X}, \emph{y}}{}
logistic loss function, returns Sum\{-log(phi(t))\}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{b} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{X} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{y} -- numpy ndarray of shape (1,N) of M functions with N samples

\end{itemize}

\end{description}\end{quote}

responses
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy array

\item[{Return out}] \leavevmode
loss value

\end{description}\end{quote}

\end{fulllineitems}

\index{mlogit\_gradient() (in module regression)}

\begin{fulllineitems}
\phantomsection\label{regression:regression.mlogit_gradient}\pysiglinewithargsret{\code{regression.}\bfcode{mlogit\_gradient}}{\emph{b}, \emph{X}, \emph{Y}}{}
calculates gradient of the multinomial logistic loss
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{b} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{X} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{y} -- numpy ndarray of shape (1,N) of M functions with N samples

\end{itemize}

\end{description}\end{quote}

responses
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy array

\item[{Return grad}] \leavevmode
gradient

\end{description}\end{quote}

\end{fulllineitems}

\index{mlogit\_loss() (in module regression)}

\begin{fulllineitems}
\phantomsection\label{regression:regression.mlogit_loss}\pysiglinewithargsret{\code{regression.}\bfcode{mlogit\_loss}}{\emph{b}, \emph{X}, \emph{Y}}{}
calculates multinomial logistic loss (negative log-likelihood)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{b} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{X} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{y} -- numpy ndarray of shape (1,N) of M functions with N samples

\end{itemize}

\end{description}\end{quote}

responses
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy array

\item[{Return nll}] \leavevmode
negative log-likelihood

\end{description}\end{quote}

\end{fulllineitems}

\index{mlogit\_warp\_grad() (in module regression)}

\begin{fulllineitems}
\phantomsection\label{regression:regression.mlogit_warp_grad}\pysiglinewithargsret{\code{regression.}\bfcode{mlogit\_warp\_grad}}{\emph{alpha}, \emph{beta}, \emph{time}, \emph{q}, \emph{y}, \emph{max\_itr=8000}, \emph{tol=1e-10}, \emph{delta=0.008}, \emph{display=0}}{}
calculates optimal warping for functional multinomial logistic regression
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{alpha} -- scalar

\item {} 
\textbf{beta} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{q} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{y} -- numpy ndarray of shape (1,N) of M functions with N samples

\end{itemize}

\end{description}\end{quote}

responses
:param max\_itr: maximum number of iterations (Default=8000)
:param tol: stopping tolerance (Default=1e-10)
:param delta: gradient step size (Default=0.008)
:param display: display iterations (Default=0)
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return gam\_old}] \leavevmode
warping function

\end{description}\end{quote}

\end{fulllineitems}

\index{phi() (in module regression)}

\begin{fulllineitems}
\phantomsection\label{regression:regression.phi}\pysiglinewithargsret{\code{regression.}\bfcode{phi}}{\emph{t}}{}
calculates logistic function, returns 1 / (1 + exp(-t))
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{t} -- scalar

\item[{Return type}] \leavevmode
numpy array

\item[{Return out}] \leavevmode
return value

\end{description}\end{quote}

\end{fulllineitems}

\index{regression\_warp() (in module regression)}

\begin{fulllineitems}
\phantomsection\label{regression:regression.regression_warp}\pysiglinewithargsret{\code{regression.}\bfcode{regression\_warp}}{\emph{beta}, \emph{time}, \emph{q}, \emph{y}, \emph{alpha}}{}
calculates optimal warping for function linear regression
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{beta} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{q} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{y} -- numpy ndarray of shape (1,N) of M functions with N samples

\end{itemize}

\end{description}\end{quote}

responses
:param alpha: numpy scalar
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy array

\item[{Return gamma\_new}] \leavevmode
warping function

\end{description}\end{quote}

\end{fulllineitems}



\chapter{SRVF Geodesic Computation}
\label{geodesic:module-geodesic}\label{geodesic:srvf-geodesic-computation}\label{geodesic::doc}\index{geodesic (module)}
geodesic calculation for SRVF (curves) open and closed)

moduleauthor:: Derek Tucker \textless{}\href{mailto:dtucker@stat.fsu.edu}{dtucker@stat.fsu.edu}\textgreater{}
\index{back\_parallel\_transport() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.back_parallel_transport}\pysiglinewithargsret{\code{geodesic.}\bfcode{back\_parallel\_transport}}{\emph{u1}, \emph{alpha}, \emph{basis}, \emph{T=100}, \emph{k=5}}{}
backwards parallel translates q1 and q2 along manifold
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{u1} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{alpha} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{basis} -- list numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{T} -- Number of samples of curve (Default = 100)

\item {} 
\textbf{k} -- number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return utilde}] \leavevmode
translated vector

\end{description}\end{quote}

\end{fulllineitems}

\index{calc\_alphadot() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.calc_alphadot}\pysiglinewithargsret{\code{geodesic.}\bfcode{calc\_alphadot}}{\emph{alpha}, \emph{basis}, \emph{T=100}, \emph{k=5}}{}
calculates derivative along the path alpha
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{alpha} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{basis} -- list of numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{T} -- Number of samples of curve (Default = 100)

\item {} 
\textbf{k} -- number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return alphadot}] \leavevmode
derivative of alpha

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_energy() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.calculate_energy}\pysiglinewithargsret{\code{geodesic.}\bfcode{calculate\_energy}}{\emph{alphadot}, \emph{T=100}, \emph{k=5}}{}
calculates energy along path
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{alphadot} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{T} -- Number of samples of curve (Default = 100)

\item {} 
\textbf{k} -- number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy scalar

\item[{Return E}] \leavevmode
energy

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_gradE() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.calculate_gradE}\pysiglinewithargsret{\code{geodesic.}\bfcode{calculate\_gradE}}{\emph{u}, \emph{utilde}, \emph{T=100}, \emph{k=5}}{}
calculates gradient of energy along path
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{u} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{utilde} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{T} -- Number of samples of curve (Default = 100)

\item {} 
\textbf{k} -- number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy scalar

\item[{Return gradE}] \leavevmode
gradient of energy

\item[{Return normgradE}] \leavevmode
norm of gradient of energy

\end{description}\end{quote}

\end{fulllineitems}

\index{cov\_integral() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.cov_integral}\pysiglinewithargsret{\code{geodesic.}\bfcode{cov\_integral}}{\emph{alpha}, \emph{alphadot}, \emph{basis}, \emph{T=100}, \emph{k=5}}{}
Calculates covariance along path alpha
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{alpha} -- numpy ndarray of shape (2,M) of M samples (first curve)

\item {} 
\textbf{alphadot} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{basis} -- list numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{T} -- Number of samples of curve (Default = 100)

\item {} 
\textbf{k} -- number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return u}] \leavevmode
covariance

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_basis\_normal\_path() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.find_basis_normal_path}\pysiglinewithargsret{\code{geodesic.}\bfcode{find\_basis\_normal\_path}}{\emph{alpha}, \emph{k=5}}{}
computes orthonormalized basis vectors to the normal space at each of the
k points (q-functions) of the path alpha
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{alpha} -- numpy ndarray of shape (2,M) of M samples (path)

\item {} 
\textbf{k} -- number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return basis}] \leavevmode
basis vectors along the path

\end{description}\end{quote}

\end{fulllineitems}

\index{geod\_dist\_path\_strt() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.geod_dist_path_strt}\pysiglinewithargsret{\code{geodesic.}\bfcode{geod\_dist\_path\_strt}}{\emph{beta}, \emph{k=5}}{}
calculate geodisc distance for path straightening
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{beta} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{k} -- number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy scalar

\item[{Return dist}] \leavevmode
geodesic distance

\end{description}\end{quote}

\end{fulllineitems}

\index{geod\_sphere() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.geod_sphere}\pysiglinewithargsret{\code{geodesic.}\bfcode{geod\_sphere}}{\emph{beta1}, \emph{beta2}, \emph{k=5}}{}
This function caluclates the geodecis between open curves beta1 and
beta2 with k steps along path
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{beta1} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{beta2} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{k} -- number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return dist}] \leavevmode
geodesic distance

\item[{Return path}] \leavevmode
geodesic path

\item[{Return O}] \leavevmode
rotation matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{gram\_schmidt() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.gram_schmidt}\pysiglinewithargsret{\code{geodesic.}\bfcode{gram\_schmidt}}{\emph{basis}}{}
Performs Gram Schmidt Orthogonlization of a basis\_o
\begin{quote}
\begin{quote}\begin{description}
\item[{param basis}] \leavevmode
list of numpy ndarray of shape (2,M) of M samples

\item[{rtype}] \leavevmode
list of numpy ndarray

\item[{return basis\_o}] \leavevmode
orthogonlized basis

\end{description}\end{quote}
\end{quote}

\end{fulllineitems}

\index{init\_path\_geod() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.init_path_geod}\pysiglinewithargsret{\code{geodesic.}\bfcode{init\_path\_geod}}{\emph{beta1}, \emph{beta2}, \emph{T=100}, \emph{k=5}}{}
Initializes a path in cal\{C\}. beta1, beta2 are already
standardized curves. Creates a path from beta1 to beta2 in
shape space, then projects to the closed shape manifold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{beta1} -- numpy ndarray of shape (2,M) of M samples (first curve)

\item {} 
\textbf{beta2} -- numpy ndarray of shape (2,M) of M samples (end curve)

\item {} 
\textbf{T} -- Number of samples of curve (Default = 100)

\item {} 
\textbf{k} -- number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return alpha}] \leavevmode
a path between two q-functions

\item[{Return beta}] \leavevmode
a path between two curves

\item[{Return O}] \leavevmode
rotation matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_path\_rand() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.init_path_rand}\pysiglinewithargsret{\code{geodesic.}\bfcode{init\_path\_rand}}{\emph{beta1}, \emph{beta\_mid}, \emph{beta2}, \emph{T=100}, \emph{k=5}}{}
Initializes a path in cal\{C\}. beta1, beta\_mid beta2 are already
standardized curves. Creates a path from beta1 to beta\_mid to beta2 in
shape space, then projects to the closed shape manifold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{beta1} -- numpy ndarray of shape (2,M) of M samples (first curve)

\item {} 
\textbf{betamid} -- numpy ndarray of shape (2,M) of M samples (mid curve)

\item {} 
\textbf{beta2} -- numpy ndarray of shape (2,M) of M samples (end curve)

\item {} 
\textbf{T} -- Number of samples of curve (Default = 100)

\item {} 
\textbf{k} -- number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return alpha}] \leavevmode
a path between two q-functions

\item[{Return beta}] \leavevmode
a path between two curves

\item[{Return O}] \leavevmode
rotation matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{parallel\_translate() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.parallel_translate}\pysiglinewithargsret{\code{geodesic.}\bfcode{parallel\_translate}}{\emph{w}, \emph{q1}, \emph{q2}, \emph{basis}}{}
parallel translates q1 and q2 along manifold
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{w} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{q1} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{q2} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{basis} -- list of numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return wbar}] \leavevmode
translated vector

\end{description}\end{quote}

\end{fulllineitems}

\index{path\_straightening() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.path_straightening}\pysiglinewithargsret{\code{geodesic.}\bfcode{path\_straightening}}{\emph{beta1}, \emph{beta2}, \emph{betamid}, \emph{init='rand'}, \emph{T=100}, \emph{k=5}}{}
Perform path straigtening to find geodesic between two shapes in either
the space of closed curves or the space of affine standardized curves.
This algorithm follows the steps outlined in section 4.6 of the
manuscript.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{beta1} -- numpy ndarray of shape (2,M) of M samples (first curve)

\item {} 
\textbf{beta2} -- numpy ndarray of shape (2,M) of M samples (end curve)

\item {} 
\textbf{betamid} -- numpy ndarray of shape (2,M) of M samples (mid curve
Default = NULL, only needed for init ``rand'')

\item {} 
\textbf{init} -- initilizae path geodesic or random (Default = ``rand'')

\item {} 
\textbf{T} -- Number of samples of curve (Default = 100)

\item {} 
\textbf{k} -- number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return dist}] \leavevmode
geodesic distance

\item[{Return path}] \leavevmode
geodesic path

\item[{Return pathsqnc}] \leavevmode
geodesic path sequence

\item[{Return E}] \leavevmode
energy

\end{description}\end{quote}

\end{fulllineitems}

\index{project\_tangent() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.project_tangent}\pysiglinewithargsret{\code{geodesic.}\bfcode{project\_tangent}}{\emph{w}, \emph{q}, \emph{basis}}{}
projects srvf to tangent space w using basis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{w} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{q} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{basis} -- list of numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return wproj}] \leavevmode
projected q

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_path() (in module geodesic)}

\begin{fulllineitems}
\phantomsection\label{geodesic:geodesic.update_path}\pysiglinewithargsret{\code{geodesic.}\bfcode{update\_path}}{\emph{alpha}, \emph{beta}, \emph{gradE}, \emph{delta}, \emph{T=100}, \emph{k=5}}{}
Update the path along the direction -gradE
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{alpha} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{beta} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{gradE} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{delta} -- gradient paramenter

\item {} 
\textbf{T} -- Number of samples of curve (Default = 100)

\item {} 
\textbf{k} -- number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy scalar

\item[{Return alpha}] \leavevmode
updated path of srvfs

\item[{Return beta}] \leavevmode
updated path of curves

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Utility Functions}
\label{utility_functions:utility-functions}\label{utility_functions:module-utility_functions}\label{utility_functions::doc}\index{utility\_functions (module)}
Utility functions for SRSF Manipulations

moduleauthor:: Derek Tucker \textless{}\href{mailto:dtucker@stat.fsu.edu}{dtucker@stat.fsu.edu}\textgreater{}
\index{SqrtMean() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.SqrtMean}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{SqrtMean}}{\emph{gam}}{}
calculates the srsf of warping functions with corresponding shooting vectors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{gam} -- numpy ndarray of shape (M,N) of M warping functions
with N samples

\item[{Return type}] \leavevmode
2 numpy ndarray and vector

\item[{Return mu}] \leavevmode
Karcher mean psi function

\item[{Return gam\_mu}] \leavevmode
vector of dim N which is the Karcher mean warping function

\item[{Return psi}] \leavevmode
numpy ndarray of shape (M,N) of M SRSF of the warping functions

\item[{Return vec}] \leavevmode
numpy ndarray of shape (M,N) of M shooting vectors

\end{description}\end{quote}

\end{fulllineitems}

\index{SqrtMeanInverse() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.SqrtMeanInverse}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{SqrtMeanInverse}}{\emph{gam}}{}
finds the inverse of the mean of the set of the diffeomorphisms gamma
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{gam} -- numpy ndarray of shape (M,N) of M warping functions
with N samples

\item[{Return type}] \leavevmode
vector

\item[{Return gamI}] \leavevmode
inverse of gam

\end{description}\end{quote}

\end{fulllineitems}

\index{cumtrapzmid() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.cumtrapzmid}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{cumtrapzmid}}{\emph{x}, \emph{y}, \emph{c}}{}
cumulative trapezoidal numerical integration taken from midpoint
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{x} -- vector of size N describing the time samples

\item {} 
\textbf{y} -- vector of size N describing the function

\item {} 
\textbf{c} -- midpoint

\end{itemize}

\item[{Return type}] \leavevmode
vector

\item[{Return fa}] \leavevmode
cumulative integration

\end{description}\end{quote}

\end{fulllineitems}

\index{diffop() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.diffop}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{diffop}}{\emph{n}, \emph{binsize=1}}{}
Creates a second order differential operator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{n} -- dimension

\item {} 
\textbf{binsize} -- dx (default = 1)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return m}] \leavevmode
matrix describing differential operator

\end{description}\end{quote}

\end{fulllineitems}

\index{elastic\_distance() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.elastic_distance}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{elastic\_distance}}{\emph{f1}, \emph{f2}, \emph{time}, \emph{lam=0.0}}{}
''
calculates the distances between function, where f1 is aligned to
f2. In other words
calculates the elastic distances
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f1} -- vector of size N

\item {} 
\textbf{f2} -- vector of size N

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{lam} -- controls the elasticity (default = 0.0)

\end{itemize}

\item[{Return type}] \leavevmode
scalar

\item[{Return Dy}] \leavevmode
amplitude distance

\item[{Return Dx}] \leavevmode
phase distance

\end{description}\end{quote}

\end{fulllineitems}

\index{f\_K\_fold() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.f_K_fold}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{f\_K\_fold}}{\emph{Nobs}, \emph{K=5}}{}
generates sample indices for K-fold cross validation

:param Nobs number of observations
:param K number of folds
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return train}] \leavevmode
train indexes (Nobs*(K-1)/K X K)

\item[{Return test}] \leavevmode
test indexes (Nobs*(1/K) X K)

\end{description}\end{quote}

\end{fulllineitems}

\index{f\_to\_srsf() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.f_to_srsf}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{f\_to\_srsf}}{\emph{f}, \emph{time}, \emph{smooth=False}}{}
converts f to a square-root slope function (SRSF)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} -- vector of size N samples

\item {} 
\textbf{time} -- vector of size N describing the sample points

\end{itemize}

\item[{Return type}] \leavevmode
vector

\item[{Return q}] \leavevmode
srsf of f

\end{description}\end{quote}

\end{fulllineitems}

\index{geigen() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.geigen}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{geigen}}{\emph{Amat}, \emph{Bmat}, \emph{Cmat}}{}
generalized eigenvalue problem of the form

max tr L'AM / sqrt(tr L'BL tr M'CM) w.r.t. L and M

:param Amat numpy ndarray of shape (M,N)
:param Bmat numpy ndarray of shape (M,N)
:param Bmat numpy ndarray of shape (M,N)
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return values}] \leavevmode
eigenvalues

\item[{Return Lmat}] \leavevmode
left eigenvectors

\item[{Return Mmat}] \leavevmode
right eigenvectors

\end{description}\end{quote}

\end{fulllineitems}

\index{gradient\_spline() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.gradient_spline}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{gradient\_spline}}{\emph{time}, \emph{f}, \emph{smooth=False}}{}
This function takes the gradient of f using b-spline smoothing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{f} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{smooth} -- smooth data (default = F)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy ndarray

\item[{Return f0}] \leavevmode
smoothed functions functions

\item[{Return g}] \leavevmode
first derivative of each function

\item[{Return g2}] \leavevmode
second derivative of each function

\end{description}\end{quote}

\end{fulllineitems}

\index{innerprod\_q() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.innerprod_q}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{innerprod\_q}}{\emph{time}, \emph{q1}, \emph{q2}}{}
calculates the innerproduct between two srsfs

:param time vector descrbing time samples
:param q1 vector of srsf 1
:param q2 vector of srsf 2
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
scalar

\item[{Return val}] \leavevmode
inner product value

\end{description}\end{quote}

\end{fulllineitems}

\index{invertGamma() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.invertGamma}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{invertGamma}}{\emph{gam}}{}
finds the inverse of the diffeomorphism gamma
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{gam} -- vector describing the warping function

\item[{Return type}] \leavevmode
vector

\item[{Return gamI}] \leavevmode
inverse of gam

\end{description}\end{quote}

\end{fulllineitems}

\index{optimum\_reparam() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.optimum_reparam}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{optimum\_reparam}}{\emph{q1}, \emph{time}, \emph{q2}, \emph{lam=0.0}}{}
calculates the warping to align srsf q2 to q1
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{q1} -- vector of size N or array of NxM samples of first SRSF

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{q2} -- vector of size N or array of NxM samples samples of second SRSF

\item {} 
\textbf{lam} -- controls the amount of elasticity (default = 0.0)

\end{itemize}

\item[{Return type}] \leavevmode
vector

\item[{Return gam}] \leavevmode
describing the warping function used to align q2 with q1

\end{description}\end{quote}

\end{fulllineitems}

\index{optimum\_reparam\_pair() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.optimum_reparam_pair}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{optimum\_reparam\_pair}}{\emph{q}, \emph{time}, \emph{q1}, \emph{q2}, \emph{lam=0.0}}{}
calculates the warping to align srsf pair q1 and q2 to q
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{q} -- vector of size N or array of NxM samples of first SRSF

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{q1} -- vector of size N or array of NxM samples samples of second SRSF

\item {} 
\textbf{q2} -- vector of size N or array of NxM samples samples of second SRSF

\item {} 
\textbf{lam} -- controls the amount of elasticity (default = 0.0)

\end{itemize}

\item[{Return type}] \leavevmode
vector

\item[{Return gam}] \leavevmode
describing the warping function used to align q2 with q1

\end{description}\end{quote}

\end{fulllineitems}

\index{outlier\_detection() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.outlier_detection}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{outlier\_detection}}{\emph{q}, \emph{time}, \emph{mq}, \emph{k=1.5}}{}
calculates outlier's using geodesic distances of the SRSFs from the median
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{q} -- numpy ndarray of N x M of M SRS functions with N samples

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{mq} -- median calculated using {\hyperref[time_warping:time_warping.srsf_align]{\code{time\_warping.srsf\_align()}}}

\item {} 
\textbf{k} -- cutoff threshold (default = 1.5)

\end{itemize}

\item[{Returns}] \leavevmode
q\_outlier: outlier functions

\end{description}\end{quote}

\end{fulllineitems}

\index{randomGamma() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.randomGamma}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{randomGamma}}{\emph{gam}, \emph{num}}{}
generates random warping functions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{gam} -- numpy ndarray of N x M of M of warping functions

\item {} 
\textbf{num} -- number of random functions

\end{itemize}

\item[{Returns}] \leavevmode
rgam: random warping functions

\end{description}\end{quote}

\end{fulllineitems}

\index{resamplefunction() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.resamplefunction}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{resamplefunction}}{\emph{x}, \emph{n}}{}
resample function using n points
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{x} -- functions

\item {} 
\textbf{n} -- number of points

\end{itemize}

\item[{Return type}] \leavevmode
numpy array

\item[{Return xn}] \leavevmode
resampled function

\end{description}\end{quote}

\end{fulllineitems}

\index{rgam() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.rgam}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{rgam}}{\emph{N}, \emph{sigma}, \emph{num}}{}
Generates random warping functions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{N} -- length of warping function

\item {} 
\textbf{sigma} -- variance of warping functions

\item {} 
\textbf{num} -- number of warping functions

\end{itemize}

\item[{Returns}] \leavevmode
gam: numpy ndarray of warping functions

\end{description}\end{quote}

\end{fulllineitems}

\index{smooth\_data() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.smooth_data}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{smooth\_data}}{\emph{f}, \emph{sparam}}{}
This function smooths a collection of functions using a box filter
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} -- numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\textbf{sparam} -- Number of times to run box filter (default = 25)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return f}] \leavevmode
smoothed functions functions

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_progress() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.update_progress}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{update\_progress}}{\emph{progress}}{}
This function creates a progress bar
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{progress} -- fraction of progress

\end{description}\end{quote}

\end{fulllineitems}

\index{warp\_q\_gamma() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.warp_q_gamma}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{warp\_q\_gamma}}{\emph{time}, \emph{q}, \emph{gam}}{}
warps a srsf q by gam

:param time vector describing time samples
:param q vector describing srsf
:param gam vector describing warping function
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return q\_temp}] \leavevmode
warped srsf

\end{description}\end{quote}

\end{fulllineitems}

\index{zero\_crossing() (in module utility\_functions)}

\begin{fulllineitems}
\phantomsection\label{utility_functions:utility_functions.zero_crossing}\pysiglinewithargsret{\code{utility\_functions.}\bfcode{zero\_crossing}}{\emph{Y}, \emph{q}, \emph{bt}, \emph{time}, \emph{y\_max}, \emph{y\_min}, \emph{gmax}, \emph{gmin}}{}
finds zero-crossing of optimal gamma, gam = s*gmax + (1-s)*gmin
from elastic regression model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Y} -- response

\item {} 
\textbf{q} -- predicitve function

\item {} 
\textbf{bt} -- basis function

\item {} 
\textbf{time} -- time samples

\item {} 
\textbf{y\_max} -- maximum repsonse for warping function gmax

\item {} 
\textbf{y\_min} -- minimum response for warping function gmin

\item {} 
\textbf{gmax} -- max warping function

\item {} 
\textbf{gmin} -- min warping fucntion

\end{itemize}

\item[{Return type}] \leavevmode
numpy array

\item[{Return gamma}] \leavevmode
optimal warping function

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Curve Functions}
\label{curve_functions:curve-functions}\label{curve_functions:module-curve_functions}\label{curve_functions::doc}\index{curve\_functions (module)}
functions for SRVF curve manipulations

moduleauthor:: Derek Tucker \textless{}\href{mailto:dtucker@stat.fsu.edu}{dtucker@stat.fsu.edu}\textgreater{}
\index{calc\_j() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.calc_j}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{calc\_j}}{\emph{basis}}{}
Calculates Jacobian matrix from normal basis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{basis} -- list of numpy ndarray of shape (2,M) of M samples basis

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return j}] \leavevmode
Jacobian

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_variance() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.calculate_variance}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{calculate\_variance}}{\emph{beta}}{}
This function calculates variance of curve beta
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{beta} -- numpy ndarray of shape (2,M) of M samples

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return variance}] \leavevmode
variance

\end{description}\end{quote}

\end{fulllineitems}

\index{calculatecentroid() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.calculatecentroid}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{calculatecentroid}}{\emph{beta}}{}
This function calculates centroid of a parameterized curve
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{beta} -- numpy ndarray of shape (2,M) of M samples

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return centroid}] \leavevmode
center coordinates

\end{description}\end{quote}

\end{fulllineitems}

\index{curve\_to\_q() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.curve_to_q}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{curve\_to\_q}}{\emph{beta}}{}
This function converts curve beta to srvf q
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{beta} -- numpy ndarray of shape (2,M) of M samples

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return q}] \leavevmode
srvf of curve

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_basis\_normal() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.find_basis_normal}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{find\_basis\_normal}}{\emph{q}}{}
Finds the basis normal to the srvf
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{q1} -- numpy ndarray of shape (2,M) of M samples

\item[{Return type}] \leavevmode
list of numpy ndarray

\item[{Return basis}] \leavevmode
list containing basis vectors

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_best\_rotation() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.find_best_rotation}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{find\_best\_rotation}}{\emph{q1}, \emph{q2}}{}
This function calculates the best rotation between two srvfs using
procustes rigid alignment
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{q1} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{q2} -- numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return q2new}] \leavevmode
optimal rotated q2 to q1

\item[{Return R}] \leavevmode
rotation matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_rotation\_and\_seed\_coord() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.find_rotation_and_seed_coord}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{find\_rotation\_and\_seed\_coord}}{\emph{beta1}, \emph{beta2}}{}
This function returns a candidate list of optimally oriented and
registered (seed) shapes w.r.t. beta1
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{beta2} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{q2} -- numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return beta2new}] \leavevmode
optimal rotated beta2 to beta1

\item[{Return O}] \leavevmode
rotation matrix

\item[{Return tau}] \leavevmode
seed

\end{description}\end{quote}

\end{fulllineitems}

\index{group\_action\_by\_gamma() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.group_action_by_gamma}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{group\_action\_by\_gamma}}{\emph{q}, \emph{gamma}}{}
This function reparamerized srvf q by gamma
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{gamma} -- numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return qn}] \leavevmode
reparatermized srvf

\end{description}\end{quote}

\end{fulllineitems}

\index{group\_action\_by\_gamma\_coord() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.group_action_by_gamma_coord}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{group\_action\_by\_gamma\_coord}}{\emph{f}, \emph{gamma}}{}
This function reparamerized curve f by gamma
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{gamma} -- numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return fn}] \leavevmode
reparatermized curve

\end{description}\end{quote}

\end{fulllineitems}

\index{innerprod\_q() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.innerprod_q}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{innerprod\_q}}{\emph{q1}, \emph{q2}}{}
This function calculates the innerproduct in srvf space
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{q1} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{q2} -- numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return val}] \leavevmode
inner product

\end{description}\end{quote}

\end{fulllineitems}

\index{optimum\_reparam\_curve() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.optimum_reparam_curve}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{optimum\_reparam\_curve}}{\emph{q1}, \emph{q2}, \emph{lam=0.0}}{}
calculates the warping to align srsf q2 to q1
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{q1} -- matrix of size nxN or array of NxM samples of first SRVF

\item {} 
\textbf{time} -- vector of size N describing the sample points

\item {} 
\textbf{q2} -- matrix of size nxN or array of NxM samples samples of second SRVF

\item {} 
\textbf{lam} -- controls the amount of elasticity (default = 0.0)

\end{itemize}

\item[{Return type}] \leavevmode
vector

\item[{Return gam}] \leavevmode
describing the warping function used to align q2 with q1

\end{description}\end{quote}

\end{fulllineitems}

\index{pre\_proc\_curve() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.pre_proc_curve}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{pre\_proc\_curve}}{\emph{beta}, \emph{T=100}}{}
This function prepcoessed a curve beta to set of closed curves
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{beta} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{T} -- number of samples (default = 100)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return betanew}] \leavevmode
projected beta

\item[{Return qnew}] \leavevmode
projected srvf

\item[{Return A}] \leavevmode
alignment matrix (not used currently)

\end{description}\end{quote}

\end{fulllineitems}

\index{project\_curve() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.project_curve}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{project\_curve}}{\emph{q}}{}
This function projects srvf q to set of close curves
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{q} -- numpy ndarray of shape (2,M) of M samples

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return qproj}] \leavevmode
project srvf

\end{description}\end{quote}

\end{fulllineitems}

\index{psi() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.psi}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{psi}}{\emph{x}, \emph{a}, \emph{q}}{}
This function formats variance output
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{x} -- numpy ndarray of shape (2,M) of M samples curve

\item {} 
\textbf{a} -- numpy ndarray of shape (2,1) mean

\item {} 
\textbf{q} -- numpy ndarray of shape (2,M) of M samples srvf

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return psi1}] \leavevmode
variance

\item[{Return psi2}] \leavevmode
cross variance

\item[{Return psi3}] \leavevmode
curve end

\item[{Return psi4}] \leavevmode
curve end

\end{description}\end{quote}

\end{fulllineitems}

\index{q\_to\_curve() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.q_to_curve}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{q\_to\_curve}}{\emph{q}}{}
This function converts srvf to beta
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{q} -- numpy ndarray of shape (2,M) of M samples

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return beta}] \leavevmode
parameterized curve

\end{description}\end{quote}

\end{fulllineitems}

\index{resamplecurve() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.resamplecurve}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{resamplecurve}}{\emph{x}, \emph{N=100}}{}
This function resamples a curve to have N samples
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{x} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{N} -- Number of samples for new curve (default = 100)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return xn}] \leavevmode
resampled curve

\end{description}\end{quote}

\end{fulllineitems}

\index{shift\_f() (in module curve\_functions)}

\begin{fulllineitems}
\phantomsection\label{curve_functions:curve_functions.shift_f}\pysiglinewithargsret{\code{curve\_functions.}\bfcode{shift\_f}}{\emph{f}, \emph{tau}}{}
shifts a curve f by tau
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{f} -- numpy ndarray of shape (2,M) of M samples

\item {} 
\textbf{tau} -- scalar

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return fn}] \leavevmode
shifted curve

\end{description}\end{quote}

\end{fulllineitems}


References:
\begin{quote}

Srivastava, A., Wu, W., Kurtek, S., Klassen, E. and Marron, J. S. (2011).
Registration of Functional Data Using Fisher-Rao Metric.
arXiv:1103.3817v2 {[}math.ST{]}.

Tucker, J. D., Wu, W. and Srivastava, A. (2013). Generative models for
functional data using phase and amplitude separation. Computational
Statistics and Data Analysis 61, 50-66.

Joshi, S.H., Srivastava, A., Klassen, E. and Jermyn, I. (2007).
A Novel Representation for Computing Geodesics Between n-Dimensional
Elastic Curves. IEEE Conference on computer Vision and Pattern Recognition
(CVPR), Minneapolis, MN.

Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape analysis
of elastic curves in euclidean spaces. Pattern Analysis and Machine
Intelligence, IEEE Transactions on 33 (7), 1415 –1428.
\end{quote}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{c}
\item {\texttt{curve\_functions}}, \pageref{curve_functions:module-curve_functions}
\indexspace
\bigletter{f}
\item {\texttt{fPCA}}, \pageref{fPCA:module-fPCA}
\item {\texttt{fPLS}}, \pageref{fPLS:module-fPLS}
\indexspace
\bigletter{g}
\item {\texttt{gauss\_model}}, \pageref{gauss_model:module-gauss_model}
\item {\texttt{geodesic}}, \pageref{geodesic:module-geodesic}
\indexspace
\bigletter{r}
\item {\texttt{regression}}, \pageref{regression:module-regression}
\indexspace
\bigletter{t}
\item {\texttt{time\_warping}}, \pageref{time_warping:module-time_warping}
\indexspace
\bigletter{u}
\item {\texttt{utility\_functions}}, \pageref{utility_functions:module-utility_functions}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
